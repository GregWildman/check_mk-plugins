#!/usr/bin/env python
# Telegram with Graphs

# Copyright Mathias Kettner  2013  mk@mathias-kettner.de
#           Stefan Gehn      2016  stefan+cmk@srcxbox.net
#           Greg Wildman     2017  greg@techno.co.za

# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Telegram notification based on mail notification from check_mk

import os, re, sys, urllib, urllib2, requests
import base64

try:
    from simplejson import json
except ImportError:
    import json


tmpl_host_text = """*Check_MK: $HOSTNAME$ - $EVENT_TXT$*
```
Host:     $HOSTNAME$
Alias:    $HOSTALIAS$
Address:  $HOSTADDRESS$
Event:    $EVENT_TXT$
Output:   $HOSTOUTPUT$

$LONGHOSTOUTPUT$```"""

tmpl_service_text = """*Check_MK: $HOSTNAME$/$SERVICEDESC$ $EVENT_TXT$*
```
Host:     $HOSTNAME$
Alias:    $HOSTALIAS$
Address:  $HOSTADDRESS$
Service:  $SERVICEDESC$
Event:    $EVENT_TXT$
Output:   $SERVICEOUTPUT$

$LONGSERVICEOUTPUT$```"""

attachments = []

def substitute_context(template, context):
    # First replace all known variables
    for varname, value in context.items():
        template = template.replace('$'+varname+'$', value)

    # Remove the rest of the variables and make them empty
    template = re.sub("\$[A-Z_][A-Z_0-9]*\$", "", template)
    return template

def construct_message_text(context):
    notification_type = context["NOTIFICATIONTYPE"]
    if notification_type in [ "PROBLEM", "RECOVERY" ]:
        txt_info = "$PREVIOUS@HARDSHORTSTATE$ -> $@SHORTSTATE$"
    elif notification_type.startswith("FLAP"):
        if "START" in notification_type:
            txt_info = "Started Flapping"
        else:
            txt_info = "Stopped Flapping ($@SHORTSTATE$)"
    elif notification_type.startswith("DOWNTIME"):
        what = notification_type[8:].title()
        txt_info = "Downtime " + what + " ($@SHORTSTATE$)"
    elif notification_type == "ACKNOWLEDGEMENT":
        txt_info = "Acknowledged ($@SHORTSTATE$)"
    elif notification_type == "CUSTOM":
        txt_info = "Custom Notification ($@SHORTSTATE$)"
    else:
        txt_info = notification_type # Should neven happen

    txt_info = substitute_context(txt_info.replace("@", context["WHAT"]), context)

    context["EVENT_TXT"] = txt_info

    if context['WHAT'] == 'HOST':
        tmpl_text = tmpl_host_text
    else:
        tmpl_text = tmpl_service_text

    return substitute_context(tmpl_text, context)

def fetch_notification_context():
    context = {}
    for (var, value) in os.environ.items():
        if var.startswith("NOTIFY_"):
            context[var[7:]] = value.decode("utf-8")
    return context

##
## Graphs
##
## -------------------------------------------------------------------------------------------------------------
def fetch_pnp_data(context, params):
    try:
        # Autodetect the path in OMD environments
        path = "%s/share/pnp4nagios/htdocs/index.php" % context['OMD_ROOT'].encode('utf-8')
        php_save_path = "-d session.save_path=%s/tmp/php/session" % context['OMD_ROOT'].encode('utf-8')
        env = 'REMOTE_USER="check-mk" SKIP_AUTHORIZATION=1'
    except:
        # Non-omd environment - use plugin argument 1
        path = context.get('PARAMETER_1', '')
        php_save_path = "" # Using default path
        skip_authorization = False
        env = 'REMOTE_USER="%s"' % context['CONTACTNAME'].encode('utf-8')

    if not os.path.exists(path):
        raise GraphException('Unable to locate pnp4nagios index.php (%s)' % path)

    return os.popen('%s php %s %s "%s"' % (env, php_save_path, path, params)).read()

def fetch_num_sources(context):
    svc_desc = context['WHAT'] == 'HOST' and '_HOST_' or context['SERVICEDESC']
    infos = fetch_pnp_data(context, '/json?host=%s&srv=%s&view=0' %
                                     (context['HOSTNAME'].encode('utf-8'), svc_desc.encode('utf-8')))
    if not infos.startswith('[{'):
        raise GraphException('Unable to fetch graph infos: %s' % extract_graph_error(infos))

    return infos.count('source=')

def fetch_graph(context, source, view = 1):
    svc_desc = context['WHAT'] == 'HOST' and '_HOST_' or context['SERVICEDESC']
    graph = fetch_pnp_data(context, '/image?host=%s&srv=%s&view=%d&source=%d' %
                                    (context['HOSTNAME'], svc_desc.encode('utf-8'), view, source))

    if graph[:8] != '\x89PNG\r\n\x1a\n':
        raise GraphException('Unable to fetch the graph: %s' % extract_graph_error(graph))

    return graph

def extract_graph_error(output):
    lines = output.splitlines()
    for nr, line in enumerate(lines):
        if "Please check the documentation for information about the following error" in line:
            return lines[nr+1]
    return output


# Fetch graphs for this object. It first tries to detect how many sources
# are available for this object. Then it loops through all sources and
# fetches retrieves the images. If a problem occurs, it is printed to
# stderr (-> notify.log) and the graph is not added to the mail.
def render_pnp_graphs(context):
    try:
        num_sources = fetch_num_sources(context)
    except GraphException, e:
        graph_error = extract_graph_error(str(e))
        if '.xml" not found.' not in graph_error:
            sys.stderr.write('Unable to fetch number of graphs: %s\n' % graph_error)
        num_sources = 0

    graph_list = []
    for source in range(0, num_sources):
        try:
            content = fetch_graph(context, source)
        except GraphException, e:
            sys.stderr.write('Unable to fetch graph: %s\n' % e)
            continue

        graph_list.append(content)

    return graph_list


def render_cmk_graphs(context):
    if context["WHAT"] == "HOST":
        svc_desc = "_HOST_"
    else:
        svc_desc = context["SERVICEDESC"]

    url = "http://localhost:%d/%s/check_mk/ajax_graph_images.py?host=%s&service=%s" % \
                    (get_apache_port(), os.environ["OMD_SITE"],
                     urllib.quote(context["HOSTNAME"]), urllib.quote(svc_desc))

    try:
        json_data = urllib2.urlopen(url).read()
    except Exception, e:
        if opt_debug:
            raise
        sys.stderr.write("ERROR: Failed to fetch graphs: %s\nURL: %s\n" % (e, url))
        return []

    try:
        base64_strings = json.loads(json_data)
    except Exception, e:
        if opt_debug:
            raise
        sys.stderr.write("ERROR: Failed to decode graphs: %s\nURL: %s\nData: %r\n" %
                                                                (e, url, json_data))
        return []

    return map(base64.b64decode, base64_strings)


def get_omd_config(key):
    for l in file(os.environ["OMD_ROOT"] + "/etc/omd/site.conf"):
        if l.startswith(key + "="):
            return l.split("=")[-1].strip("'\n")
    return None


def get_apache_port():
    port = get_omd_config("CONFIG_APACHE_TCP_PORT")
    if port == None:
        return 80
    else:
        return int(port)


def use_cmk_graphs():
    return get_omd_config("CONFIG_CORE") == "cmc"


def render_performance_graphs(context):
    if use_cmk_graphs():
        graphs = render_cmk_graphs(context)
    else:
        graphs = render_pnp_graphs(context)

    attachments, ''
    for source, graph_png in enumerate(graphs):
        if context['WHAT'] == 'HOST':
            svc_desc = '_HOST_'
        else:
            svc_desc = context['SERVICEDESC'].replace(' ', '_')
            # replace forbidden windows characters < > ? " : | \ / *
            for token in ["<", ">", "?", "\"", ":", "|", "\\", "/", "*"] :
                svc_desc = svc_desc.replace(token, "x%s" % ord(token))

        filename = '%s-%s-%d.png' % (context['HOSTNAME'], svc_desc, source)

        attachments.append((filename, graph_png))


    return attachments

## -------------------------------------------------------------------------------------------------------------

def send_telegram_message(token, chat_id, text):
    url = 'https://api.telegram.org/bot%s/sendMessage' % (token)
    data = {'chat_id':chat_id, 'text':text, 'parse_mode':'Markdown'}
    try:
        r = requests.post(url, data=data)
    except requests.exceptions.RequestException, e:
        sys.stdout.write('Cannot send Telegram message: HTTP-Error %s %s\n' % (e.code, e))

def send_telegram_picture(token, chat_id, picture):
    url = 'https://api.telegram.org/bot%s/sendPhoto' % (token)
    data = {'chat_id':chat_id, 'disable_notification':True}
    files = {'photo':picture}
    try:
        r = requests.post(url, files=files, data=data)
    except requests.exceptions.RequestException, e:
        sys.stdout.write('Cannot send Telegram picture: HTTP-Error %s %s\n' % (e.code, e))

def main():
    context = fetch_notification_context()
    telegram_bot_token = context.get('PARAMETER_1')
    if not telegram_bot_token: # e.g. not specified in notifications
        sys.stdout.write("Cannot send Telegram message: Empty BOT token as first parameter")
        sys.exit(2)
    telegram_chatid = context.get('CONTACT_TELEGRAM_CHAT_ID')
    if not telegram_chatid: # e.g. empty field in user database
        sys.stdout.write("Cannot send Telegram message: Empty destination chat id")
        sys.exit(2)
    text = construct_message_text(context)
    send_telegram_message(telegram_bot_token, telegram_chatid, text)

    # Send graphs
    try:
        graphs = render_performance_graphs(context)
        for name, contents in graphs:
	    send_telegram_picture(telegram_bot_token, telegram_chatid, contents)
        
    except Exception, e:
        sys.stdout.write("Failed to send graphs to Telegram. %s\n" % e)

main()


